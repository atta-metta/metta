Step 0:
 ☐ disabling kernel ATAGs in config.txt causes misboot in EL2H
   ☐ looks like we run in EL1H otherwise??
     ☐ need to double check EL change procedure due to this, probably EL2->EL1 switch is wrong

 ☐ Read about openocd AHB-AP configuration on cortex_a, for doing side reads on memory (for RTT)
   ☐ JLink should be able to do this for sure?
   ☐ They also mentioned slow-mode where target is halted, memory is read and target is resumed
     ☐ Should work -- quick one did NOT work, need to investigate.

Step 1:
 ✔ Could control RPi3 LEDs through mailbox interface: see @done (19-03-10 19:52)
   https://github.com/Makogan/PiOS/blob/master/source/Hardware/Graphics/mailbox.cpp#L103
 ☐ move EL2->El1 bootloader and paging stuff to the beginning of history before other things
  ☐ Boot a rust-based nano-kernel
    ✔ Xargo @done (18-02-10 18:12)
      ✔ cargo xbuild @done (19-02-03 22:53)
    ✔ Raspi build setup for xargo @done (18-02-10 18:12)
    ✔ Startup init asm @done (18-02-15 00:29)
    ✔ see how u-boot starts up and try to copy the sequence - their VC code works so hey, it should work in rust too. @done (18-03-16 01:23) - was missing setting sp
    ☐ Follow cs140e and build
      ✔ StackVec @done (18-03-19 00:25)
        ☐ TESTS
      ✔ volatile wrappers @done (18-03-19 00:25)
        ✔ TESTS @done (19-03-10 19:52) - not needed, using rust builtins
      ✔ xmodem protocol @done (18-03-20 01:40)
        ☐ TESTS
      ✔ ttywrite @done (18-03-21 01:06)
        ☐ TESTS
      ☐ system timer
        ☐ TESTS
      ☐ gpio driver
        ☐ TESTS
      ✔ UART @done (19-03-10 19:53)
        ☐ TESTS
        ✔ Serial print function @done (19-03-10 19:53)
        ✔ Serial port message - need to plug flyswatter with custom pinout head @done (19-03-10 19:53)
      ☐ tiny kernel shell
        ☐ TESTS
      ☐ panic_fmt
        ☐ TESTS
      ☐ ATAGS
        ☐ TESTS
      ✔ bump allocator (wee_alloc?) @done (19-03-10 19:53)
        ☐ Port wee_alloc as the startup mini-allocator for the kernel?? We basically just need to allocate a few pages of tables, so probably an allocator is not even needed at all.
        ☐ TESTS
      ☐ bin allocator (similar to what i have from Nemesis)
        ☐ TESTS
      ☐ FAT32 read-only
        ☐ TESTS
      ☐ EMMC/SD driver (see https://github.com/bztsrc/raspi3-tutorial/tree/master/0B_readsector)
        ☐ TESTS
      ☐ exception level switching
        ☐ TESTS
      ✔ exception vectors @done (19-03-10 19:54)
        ☐ TESTS
      ☐ switch to user mode
        ☐ TESTS
      ☐ timer interrupts
        ☐ TESTS
      ☐ scheduler
        ☐ TESTS
      ☐ sleep
        ☐ TESTS

 ✔ simple bitfont rendering using `bitfont` crate, @done (18-03-14 00:14)
   ✔ just grab the bitfont definition from there... @done (18-03-14 00:14)
 ☐ ttf font rendering using `rusttype` + `ttf-noto-sans` embedded font.

---------------------------------------------------

☐ Rust implementation of caps - ?


 ☐ cte = cap table entry
 ☐ mdb = ? (mdb_node_new)
 ☐ sameObjectAs()

Module loader:
 ☐ Implement separating code, data and bss sections into different privileged stretches.
 ☐ Implement module dependency tracking
        Implement dependency tracking via module_depend!() macros, .modinfo section data and module dependency graph building in module loader.
        The actual dependency information should be generated by meddler from interface info and then somehow combined into final dependency record.
        Also can generate depsgraph based on symbols resolution between modules marked for loading.
 ☐ Implement symbol resolution from already loaded modules.
 ☐ stuff like console and debug logger should be loadable modules so that other components link to the shared instance.
 ☐ can be instantiated early in kickstart and entered into pervasives? PVS(logger), PVS(console) e.g.

Cleanups:
 ☐ move types__intf_typeinfo to types::intf_typeinfo etc because of namespace linking issues
 ☐ all non-pub types should be inside `namespace types { namespace { } }` perhaps

Boot:
 ☐ Clean up the C-like code from Nemesis and turn it into robust shared kernel components with dynamic loading/resolution
 ☐ Add bootimage namespace iteration (bootimage_t::namespace_t::iterator?)
 ☐ Finish introspection and write a command line tool to interactively explore type system.
 ☐ Make a real module loader with all tables and proper memory allocation - current one seems to step over already allocated data and needs to preload things in order to work...
 ☐ Make a memory map tool to see what is allocated where, associate stretches and domains with allocated frames.
     - display it at runtime at the bottom of the screen ...
 ☐ Add generic types a-la C# to type system?

Build:
 ☐ Dependency Problem during build: changing an interface that is a base for other interfaces does not trigger rebuild of these interfaces (implicit dependency information is missing from the build system...)
 ✔ Dependency Problem during build: missing dependency of init.img on built components, so 'ninja metta' will not rebuild the iso image when necessary. @done (13-06-29 12:33)

General:
 ✔ Retarget to 64-bit and UEFI @done (18-03-16 01:33)
    - by the time i'm getting to arm there will be armv8 chips everywhere anyway.
 ☐ GLES on RPi3: https://github.com/LdB-ECM/Raspberry-Pi/blob/master/GLES2_Rotate/rpi-GLES.c

Assocfs:
  ☐ OS block cache - write tests.
  ☐ write b+tree handler
  ☐ write more unit-tests for all these modules!
  ☐ We need a simple application to start coding from the user perspective. Something simple, single focused and immensely mettaish. Ideas?
  ☐ Create architecture descriptions in increasing level of detail (@sa ANSA engineering overview).

System components:
  ☐ scheduler
  ☐ protection domains
  ☐ memory manager
  ☐ usermode

  ✔ UP @done (12-12-31 16:58)
  ☐ SMP
    * SMP - may require serious redesign
  ☐ NUMA
    * NUMA-style CPU addressing
  ✔ ARM port @done (18-03-16 01:33)
  ☐ Hosted port

Nucleus (privileged core):
 TODO: cleanly separate this code into a specialized component
  ☐ IRQ stubs
  ☐ privileged instructions
  ✔ limited set of syscalls for performing privileged instructions - @TODO: make a list now @done (18-03-16 01:34)
  * syscall/sysret, sysenter/sysexit in addition to current "int 99"
  ✔ write_pdbr @done (12-12-31 16:59)

Drivers:
  ☐ keyboard (PS/2, usb support needs more drivers)
  ☐ Device trees
        Perform scanning of the system buses and build a device tree which describes machine configuration.
        A prerequisite for device driver loading and probing.
        Device tree can be represented as a naming_context, mapping various information about devices from arc-names.
  ☐ RPi3 hardware support
    ☐ sd/mmc
    ☐ dwc usb otg
    ☐ power mgmt
    ☐ VC4
    ☐ Audio
    ☐ Wired Network
    ☐ Wifi
    ☐ Bluetooth
    ✔ Framebuffer @done (19-03-10 19:57)
  ☐ PCI
    ✔ PCI bus enumeration (enumeration works, not optimal) @done (13-06-03 10:09)
    ☐ assigning PCI irqs and handlers
  ☐ ACPI (using acpica port?)
  ☐ Device driver infra
  ☐ APIC
  ☐ IO APIC
  ☐ x2APIC
  ☐ display
    ✔ BGA driver @done (13-05-28 18:09)
   ☐ Intel GMA driver (http://www.x.org/docs/intel/)
  ☐ network
    ✔ ne2000 driver @done (13-05-28 18:09)

  * Scan pcibus
    * This needs access interface
  * Find netdev
  * Start netdev driver
    * needs irq assignment
    * needs irq handler installation
  * Send and receive packets
    * needs io fbufs
    * needs synchro events
    * needs client QoS
  * Use ipv6 packets
    * needs network stacking/layering

  ☐ PC keyboard driver
  ☐ USB bus

Services:
  ☐ typesystem
  ☐ events
  ☐ IDC
     ☐ shm transport
     ☐ marshalling & stub generator
     ☐ events plumbing between domains
     ☐ exports table & lookup
  ☐ exceptions

Applications:
  ☐ test shell
  ☐ child
  ☐ memory inspector
  ☐ symbolic debugger
  ☐ Write tests for atomic_count

Other:
    ☐ Investigate TLSF memory allocator for RT tasks
        Investigate possible use of TLSF for RT tasks. See http://rtportal.upv.es/rtmalloc/

Toolchain:
  ☐ Jotun native file format work

Baby steps:
    ☐ Port activations and handlers framework
    ☐ Port gatekeeper
    ☐ Port VCPU operations
    ☐ Implement nucleus syscalls
    ☐ Set up module namespaces tree and global context
    ☐ Port threading packages
        Threads, thread handlers, events, user-level scheduler package.
    ☐ Port IDC machinery
        IDC stubs, marshal, CS IDC stubs, IDC/Shm Transports.
    ☐ Port binder
        Binder, exports table, plumber, event channels.
    ☐ Port naming context
    ☐ Port domain manager

Meddler:
    ☐ Generate dot files with dependency information in meddler
    ☐ Use llvm doxygen scanning functionality
    ☐ Meddler: use newline as a substitute for semicolon where possible

Milestone-1:
    ☐ Start a root thread
       Start and run a single kernel thread in kernel address space with kernel (user?) privileges.

Another realistic scenario more on the HID side:
  * make a simple cli: type in an arcname and it will try to look it up and print out formatted according to the type
    * this needs events, contexts etc all running...
  * needs keyboard HID driver (PS2 or USB)
    * for USB a huge pile of protocol handling must be implemented

Testing:
    ☐ Devise a testing framework for modules
